{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Revizor","text":"<p>Welcome to Revizor.</p>"},{"location":"cli/","title":"Command-Line Interface","text":"<p>Revizor can run in one of multiple \"modes\":</p> <ul> <li>Fuzzing mode is revizor's main form of execution. It's what invokes all   components of revizor's architecture to enable hardware   fuzzing.</li> <li>Analysis mode invokes the analyser to compare existing contract traces and   hardware traces.</li> <li>Minimize mode accepts a test case and attempts to minimize its size.   It acts as a \"watered-down\" version of fuzzing mode that focuses solely on   a single test case.</li> </ul> <p>To select a mode on the command-line, begin your command with:</p> <pre><code>rvzr MODE # ... arguments go here\n\n# Where MODE can be:\n#   fuzz            for fuzzing mode\n#   analyse         for analysis mode\n#   minimize        for test case minimization mode\n</code></pre>"},{"location":"cli/#fuzzing-mode","title":"Fuzzing Mode","text":"<p>The following command-line arguments are supported in <code>fuzz</code> mode:</p> <ul> <li><code>-s</code> / <code>--instruction-set</code> - accepts a path to an XML file specifying the   instruction set revizor should use.</li> <li><code>-c</code> / <code>--config</code> - accepts a path to a YAML configuration file for revizor.</li> <li><code>-n</code> / <code>--num-test-cases</code> - accepts an integer specifying the number of test   cases to create and test during the fuzzing campaign.</li> <li><code>-i</code> / <code>--num-inputs</code> - accepts an integer specifying the number of inputs to   generate for each test case (which corresponds to the number of contract   traces to collect).</li> <li><code>-w</code> / <code>--working-directory</code> - accepts a path to a directory into which   revizor will place its output files during the campaign.</li> <li><code>-t</code> / <code>--testcase</code> - accepts a path to an existing test case for the fuzzer   to run. (Revizor will only run this test case if this is specified.)</li> <li><code>--timeout</code> - accepts an integer specifying the number of seconds to run the   fuzzer. Once the timeout has been reached, fuzzing will cease.</li> <li><code>--nonstop</code> - if enabled, this keeps the fuzzer running after it encounters a   violation. (Otherwise, if it's not specified, revizor will stop after the   first violation is found.)</li> </ul>"},{"location":"cli/#analysis-mode","title":"Analysis Mode","text":"<p>The following command-line arguments are supported in <code>analyse</code> mode:</p> <ul> <li><code>--ctraces</code> - accepts a path to a file containing contract traces.</li> <li><code>--htraces</code> - accepts a path to a file containing hardware traces.</li> <li><code>-c</code> / <code>--config</code> - accepts a path to a YAML configuration file for revizor.</li> </ul>"},{"location":"cli/#minimize-mode","title":"Minimize Mode","text":"<p>The following command-line arguments are support in <code>minimize</code> mode:</p> <ul> <li><code>-i</code> / <code>--infile</code> - accepts a path to the test case revizor will attempt to   minimize.</li> <li><code>-o</code> / <code>--outfile</code> - accepts a path specifying where the minimized version of   the original test case will be written to.</li> <li><code>-c</code> / <code>--config</code> - accepts a path to a YAML configuration file for revizor.</li> <li><code>-n</code> / <code>--num-inputs</code> - accepts an integer specifying the number of inputs to   try for the test case.</li> <li><code>-f</code> / <code>--add-fences</code> - if enabled, revizor will add as many <code>LFENCE</code>   instructions as possible to the test case's assembly code while still   preserving the violation-inducing behavior.</li> <li><code>-s</code> / <code>--instruction-set</code> - accepts a path to an XML file specifying the   instruction set revizor should use.</li> </ul>"},{"location":"config/","title":"Configuration File","text":"<p>Below is a list of the available configuration options for Revizor, which are passed down to Revizor via a config file. For an example of how to write the config file, see src/tests/big-fuzz.yaml.</p> <p>Some of the options are omitted from the list as they should not be used in a normal fuzzing campaign. For a complete list, see <code>src/config.py</code>.</p>"},{"location":"config/#contract","title":"Contract","text":"<ul> <li><code>contract_execution_clause</code> : List[str]: Execution clause.   Available options: \"seq\", \"cond\", \"bpas\", \"null-injection\".</li> <li><code>contract_observation_clause</code> [str]: Observation clause.   Available options: \"l1d\", \"memory\", \"ct\", \"pc\", \"ct-nonspecstore\", \"ctr\", \"arch\".</li> </ul>"},{"location":"config/#general-configuration","title":"General Configuration","text":"<ul> <li><code>enable_priming</code> [bool]: priming.</li> <li><code>logging_modes</code> List[str]: Verbosity of the output.   Available options:   <code>info</code> - general information about the progress of fuzzing;   <code>stat</code> - statistics the end of the fuzzing campaign;   <code>dbg_timestamp</code> - periodically print the timestamp during the fuzzing process;   <code>dbg_violation</code> - detailed information about the fuzzing progress and about the detected vulnerabilities;   <code>dbg_traces</code> - print ALL hardware and contract traces (use carefully, produces lots of text);   <code>dbg_model</code> - print a detailed trace of ALL executions on the model (use carefully, produces lots of text);   <code>dbg_coverage</code> - periodically report detailed information about the changes in coverage.</li> <li><code>multiline_output</code> [bool]: Print each output message on a separate line.   Preferred when piping the log into a file.</li> </ul>"},{"location":"config/#model-configuration","title":"Model Configuration","text":"<ul> <li><code>model</code> [str]: Model type.   Only one option is currently supported - \"unicorn\" (default).</li> <li><code>model_max_nesting</code> [int]: Maximum number of simulated mispredictions.</li> <li><code>model_max_spec_window</code> [int]: Size of the speculation window.</li> </ul>"},{"location":"config/#generator-configuration","title":"Generator Configuration","text":"<ul> <li><code>instruction_set</code>  [str]: Tested ISA.   Only one option is currently supported - \"x86-64\" (default).</li> <li><code>permitted_faults</code> [list(str)]: a list of faults that are permitted to happen during testing.</li> <li><code>generator</code> [str]: Test case generator type.   Only one option is currently supported - \"random\" (default).</li> <li><code>program_generator_seed</code> [int]: Test case generation seed.   Will use a random seed if set to zero.</li> <li><code>min_bb_per_function</code> [int]: Minimum number of basic blocks per test case.</li> <li><code>max_bb_per_function</code> [int]: Maximum number of basic blocks per test case.</li> <li><code>program_size</code> [int]: Number of instructions per test case.   The actual size might be larger because of the instrumentation.</li> <li><code>avg_mem_accesses</code> [int]: Average number of memory accesses per test case.</li> <li><code>instruction_categories</code> [list(str)]: List of instruction categories to be used when generating a test case.   Used to filter out instructions from the instruction set file passed via command line (<code>--instruction-set</code>).</li> <li><code>instruction_blocklist</code> [list(str)]: List of instructions to be excluded by the generator.   Used to filter out instructions from the instruction set file passed via command line (<code>--instruction-set</code>).</li> </ul>"},{"location":"config/#input-generator-configuration","title":"Input Generator Configuration","text":"<ul> <li><code>input_generator</code> [str]: Input generator type.   Only one option is currently supported - \"random\" (default)</li> <li><code>input_gen_seed</code> [int]: Input generation seed.   Will use a random seed if set to zero.</li> <li><code>input_gen_entropy_bits</code> [int]: Entropy of the random values created by the input generator.</li> <li><code>inputs_per_class</code> [int]: Number of inputs per input class.</li> </ul>"},{"location":"config/#executor-configuration","title":"Executor Configuration","text":"<ul> <li><code>executor</code> [str]: Executor type.   Only one option is currently supported - \"default\".</li> <li><code>executor_mode</code> [str]: Hardware trace collection mode.   Available options: 'P+P' - prime and probe; 'F+R' - flush and reload; 'E+R' - evict and reload.</li> <li><code>executor_warmups</code> [int]: Number of warmup rounds executed before starting to collect hardware traces.</li> <li><code>executor_repetitions</code> [int]: Number of repetitions while collecting hardware traces.</li> <li><code>executor_taskset</code> [int]: CPU number on which the executor is running test cases.</li> <li><code>enable_pre_run_flush</code> [bool]: If enabled, the executor will do its best to flush the microarchitectural state before running test cases.   Enabled by default.</li> </ul>"},{"location":"config/#analyser-configuration","title":"Analyser Configuration","text":"<ul> <li><code>analyser</code> [str]: Analyser type.   Only one option is currently supported - \"equivalence-classes\" (default).</li> <li><code>analyser_permit_subsets</code> [bool]: If enabled, the analyser will not label hardware traces as mismatching if they form a subset relation.   Enabled by default.</li> </ul>"},{"location":"config/#coverage-configuration","title":"Coverage Configuration","text":"<ul> <li><code>coverage_type</code> [str]: Coverage type.   Available options:   'none' - disable coverage tracking;   'dependent-pairs' - coverage of pairs of dependent instructions.</li> </ul>"},{"location":"config/#x86-specific-configuration","title":"x86-specific configuration","text":"<ul> <li><code>x86_executor_enable_ssbp_patch</code> [bool]: Enable a patch against Speculative Store Bypass.   Enabled by default.</li> <li><code>x86_executor_enable_prefetcher</code> [bool]: Enable all pretechers.   Disabled by default.</li> </ul>"},{"location":"development/","title":"Development","text":"<p>This page contains various bits of information helpful when developing and expanding Revizor.</p>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>To run automated tests you will need to install a few more dependencies: * Bash Automated Testing System * mypy * flake8</p> <p>With the dependencies installed, you can run the tests with:</p> <pre><code>make test\n</code></pre> <p>If a few (up to 3) \"Detection\" tests fail, it's fine, you might just have a slightly different microarchitecture. But if other tests fail - something is broken.</p>"},{"location":"development/#revizors-architecture","title":"Revizor's Architecture","text":"<p>Revizor has five chief components:</p> <ol> <li>Test Case Generator</li> <li>Input Generator</li> <li>Model</li> <li>Executor</li> <li>Analyser</li> </ol> <p>The Test Case Generator and Input Generator are responsible for generating random test cases to be run through the Model and Executor. The results are examined by the Analyser for contract violations.</p>"},{"location":"development/#test-case-generator","title":"Test Case Generator","text":"<p>The TCG is responsible for generating random assembly test cases. It takes an Instruction Set Specification as input in order for it to understand the instructions and syntax it can use for generation.</p>"},{"location":"development/#input-generator","title":"Input Generator","text":"<p>The IG is responsible for generating the inputs that are passed into a test case created by the TCG. Largely, this means register and memory values that the microarchitecture will be primed with before executing the test case. In this way, a single test case program can be run across several different inputs, allowing for multiple contract traces (and later, hardware traces) to be collected for analysis.</p>"},{"location":"development/#model","title":"Model","text":"<p>The Model's job is to accept test cases and inputs from the TCG &amp; IG and emulate the test case to collect contract traces. A single test case seeded with several inputs (<code>N</code> inputs) will create several contract traces (<code>N</code> contract traces) as the model's output. These are passed to the Analyser to determine input classes.</p>"},{"location":"development/#executor","title":"Executor","text":"<p>The Executor, on the other side from the Model, is responsible for running the same test cases (with the same inputs) on physical hardware to collect hardware traces. Hardware traces from the same input class are collected and studied by the Analyser to detect contract violations.</p>"},{"location":"development/#analyser","title":"Analyser","text":"<p>The Analyser receives contract traces from the Model and hardware traces from the Executor to accomplish two primary goals:</p> <ol> <li>Compare contract traces to set up input classes.</li> <li>Compare hardware traces to detect contract violations.</li> </ol>"},{"location":"development/#revizor-modules-and-interfaces","title":"Revizor Modules and Interfaces","text":"<p>Revizor's implementation and architecture is separated into multiple Python files:</p> <ul> <li><code>cli.py</code> - implements the command-line interface of revizor.</li> <li><code>config.py</code> - implements parsing and managing of revizor's YAML configuration   file.</li> <li><code>generator.py</code> - implements the Test Case Generator portion of   revizor's architecture.</li> <li><code>input_generator.py</code> - implements the Input Generator portion of   revizor's architecture.</li> <li><code>model.py</code> - implements the Unicorn-based Model portion of   revizor's architecture.</li> <li><code>executor.py</code> - implements the Executor portion of   revizor's architecture.</li> <li><code>analyser.py</code> - implements the Analyser portion of   revizor's architecture.</li> <li><code>postprocessor.py</code> - defines the <code>MinimizerViolation</code> class, used during   <code>minimize</code> mode to reduce a violation-inducing test case down to a smaller   size while still maintaining the violation-inducing behavior.</li> <li><code>fuzzer.py</code> - implements <code>fuzz</code> mode that utilizes all main components to   perform end-to-end hardware fuzzing.</li> <li><code>coverage.py</code> - will collect coverage in the future; currently not in use.</li> <li><code>factory.py</code> - used to configure revizor accordingly to the user provided   YAML configuration. Implements a simplified version of the Factory pattern:   Defines a series of dictionaries that allows revizor to choose   between various contract, generation techniques, executors, analysers, etc.   In future, it be also used to implement  multiple-ISA support.</li> <li><code>interfaces.py</code> - defines abstract classes (i.e., interfaces) of all main   components of revizor (e.g., abstract  <code>Executor</code>, <code>Model</code>, <code>TestCase</code>,    <code>Input</code>, etc)</li> <li><code>isa\\_loader.py</code> - defines the <code>InstructionSet</code> class, used to load an   ISA's specifications from a JSON file provided via the   command-line interface.</li> <li><code>service.py</code> - defines logging, statistical, and other services to all other   modules within revizor.</li> </ul>"},{"location":"development/#architecture-specific-implementation","title":"Architecture-specific Implementation","text":"<p>The modules above are ISA-independent. The architecture-specific implementations are located in the subdirectories. For example, the implementation of the modules for the x86-64 architecture is located in <code>src/x86/</code>. It's structure largely mirrors the main modules of revizor (e.g., <code>x86_model.py</code> contains x86-specific parts of the Model module). The only unique parts are:</p> <ul> <li><code>*_target_desc.py</code> - defines constants describing the ISA (e.g., a list of   available registers) and some helper functions.</li> <li><code>get_spec.py</code> - a script for transforming the ISA description provided   by the CPU vendor (different for every vendor) into a unified JSON format</li> <li><code>executor/</code> - contains a low-level implementation of the executor. The   implementation will be different for each architecture. For black-box x86 CPUs,   it is a Linux kernel module.</li> </ul>"},{"location":"development/#abstract-test-case","title":"Abstract Test Case","text":"<p>This describes a number of Python classes within revizor that define parts of an assembly test case. Revizor's TCG uses them to generate syntactically-valid assembly. The classes are defined in <code>interfaces.py</code>.</p>"},{"location":"development/#operandspec","title":"<code>OperandSpec</code>","text":"<p>The <code>OperandSpec</code> class defines a set of valid operands for any given assembly instruction. Each <code>InstructionSpec</code> object (described below) contains a list of these operand specifications. It contains properties such as:</p> <ul> <li>The <code>type</code> of operand</li> <li>The <code>width</code> of the operand</li> <li>Whether or not the operand is a <code>src</code> or <code>dest</code> operand</li> </ul>"},{"location":"development/#instructionspec","title":"<code>InstructionSpec</code>","text":"<p>This class represents a single instruction specification. It contains a name (i.e. the actual instruction mnemonic, such as <code>ADD</code>) and a list of <code>OperandSpec</code>s, defining valid operands for the instruction. It also has a number of boolean flags that indicate unique attributes about the instruction, such as:</p> <ul> <li>If the instruction contains a memory write</li> <li>If the instruction is a control-flow instruction</li> </ul>"},{"location":"development/#operand","title":"<code>Operand</code>","text":"<p>The <code>Operand</code> class defines an actual operand to be used in an instruction placed into the TCG's generated test case (not to be confused with <code>OperandSpec</code>, which is a set of rules used to define possible operand choices for an instruction). This is an abstract base class that provides a number of sub-classes:</p> <ul> <li><code>RegisterOperand</code></li> <li><code>MemoryOperand</code></li> <li><code>ImmediateOperand</code></li> <li><code>LabelOperand</code></li> <li><code>AgenOperand</code></li> <li><code>FlagsOperand</code></li> </ul>"},{"location":"development/#instruction","title":"<code>Instruction</code>","text":"<p>Similar to the relationship between <code>OperandSpec</code> and <code>Operand</code>, the <code>Instruction</code> class defines an actual instruction, constrained by an <code>InstructionSpec</code>, that is used during test case generation. It contains a list of <code>Operand</code>s and is linked to its neighboring instructions via object references.</p>"},{"location":"development/#basicblock","title":"<code>BasicBlock</code>","text":"<p>Thisi class represents a single basic block within the generated test case (a basic block is a straight-line sequence of assembly instructions that has a single entry and exit point). It contains a list of all instructions contained within, references to its successor basic block(s), and a list of \"terminator\" instructions (instructions that exit the basic block, such as a branch).</p>"},{"location":"development/#function","title":"<code>Function</code>","text":"<p>This object represents a collection of basic blocks that form a function. It has an \"entry\" basic block and an \"exit\" basic block, along with a list of all basic blocks that comprise the function.</p>"},{"location":"development/#testcasedag","title":"<code>TestCaseDAG</code>","text":"<p>DAG is short for Directed Acyclic Graph. This object represents the entire test case's control flow. It contains a list of functions that, within, define all instructions to be written out to the test case's assembly file.</p>"},{"location":"fuzzing-guide/","title":"Guide on running a testing campaign and analyzing a violation","text":"<p>In this guide, we will walk through the process of testing a CPU for unexpected speculative leaks with Revizor. We will also show how to analyze a contract violation discovered by this campaign.</p> <p>This example is based on a real testing campaign that led to a discovery of Zero Division Injection, described in Hide&amp;Seek with Spectres.</p>"},{"location":"fuzzing-guide/#preparation","title":"Preparation","text":"<p>We perform a fuzzing campaign in which we test arithmetic operations on an x86-64 CPUs. As the source of side channel information (i.e., the source of hardware traces), we chose L1D cache. In other words, this campaign will test the information that arithmetic operations can expose through an L1D cache.</p> <p>For the sake of this example, let's assume that we do not know of any speculative vulnerabilities that could be triggered by these instructions. Accordingly, our expected contract is going to be <code>ct-seq</code>, a contract that describes cache leakage for non-speculating instructions.</p> <p>We encode this setup in the following configuration file: <pre><code>instruction_set: x86-64 # target instruction set\n\n# define a pool of tested instructions\ninstruction_categories:\n- BASE-BINARY  # BINARY is a keyword for arithmetic operations\n\n# by default, Revizor will not generate 64-bit divisions\n# we disable this behavior\nx86_disable_div64: false\n\n# since we are relying on a cache side channel to collect hardware traces,\n# we expect to observe the addresses of loads and stores in the traces,\n# as well as the changes in the PC\ncontract_observation_clause: loads+stores+pc\n\n# we expect to see not speculation in this fuzzing campaign\ncontract_execution_clause:\n- no_speculation\n\n# use Prime+Probe to collect hardware traces\nexecutor_mode: P+P\n\n# enable some optimization features to make fuzzing faster\nenable_speculation_filter: true\nenable_observation_filter: true\n\n# by default Revizor adds conditional branches to all test cases\n# since we are not interested in branches in this experiment,\n# disable them\nmin_bb_per_function: 1\nmax_bb_per_function: 1\n</code></pre></p> <p>We save the configuration into a file (<code>config.yaml</code>) and start a fuzzing campaign.</p>"},{"location":"fuzzing-guide/#fuzzing-campaign","title":"Fuzzing Campaign","text":"<p>We start Revizor with the following command:</p> <p><pre><code>rvzr fuzz -s base.json -c config.yaml -n 100000 -i 100 -w ./results\n</code></pre> (use <code>./revizor.py</code> instead of <code>rvzr</code> if you want to run Revizor directly from the source directory)</p> <p>Here * <code>-s base.json</code> - tells Revizor where to find a description of the tested instructions * <code>-c config.yaml</code> - points Revizor to the configuration file described above * <code>-n 100000</code> - number of randomly-generated programs to be tested. Note that 100k programs will be tested only if none of them surfaces a contract violation; otherwise, Revizor will stop as soon as it detects a violation * <code>-i 100</code> - number of inputs per test case * <code>-w ./results</code> - directory where the detected violations will be stored.</p> <p>After about an hour of fuzzing, Revizor finds a violation, saves the corresponding program into <code>./results/violation&lt;timestamp&gt;.asm</code>, and terminates.</p> <p>The violation on its own is already a sign that something unexpected is going on: Since we were testing against a contract that does not permit speculation (<code>no_speculation</code> in <code>config.yaml</code>), this violation indicates that Revizor found a program that speculatively leaks information. This is a new finding because there has been previously no reports of speculative leaks caused by arithmetic instructions.</p>"},{"location":"fuzzing-guide/#analyzing-the-violation","title":"Analyzing The Violation","text":"<p>The next step is to find out what caused this violation. The program that surfaced a violation looks like this:</p> <p><pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\n.function_main:\n.bb_main.entry:\nJMP .bb_main.0\n.bb_main.0:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nSUB RAX, -63\nNEG BX\nINC DL\nAND RAX, 0b1111111111111 # instrumentation\nLOCK ADC dword ptr [R14 + RAX], -12\nAND RBX, 0b1111111111111 # instrumentation\nSUB CL, byte ptr [R14 + RBX]\nAND RDI, 0b1111111111111 # instrumentation\nCMP word ptr [R14 + RDI], -24\nCMP RAX, 382711631\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nIMUL CL\nSBB AL, -106\nCMP RAX, 383545172\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nADD word ptr [R14 + RBX], -102\nAND RBX, 0b1111111111111 # instrumentation\nLOCK INC dword ptr [R14 + RBX]\nAND RSI, 0b1111111111111 # instrumentation\nADD EDX, dword ptr [R14 + RSI]\nSUB AL, 66\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nIMUL ESI, EBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\nADC DIL, 32\nSBB BL, DL\nOR RSI, 1 # instrumentation\nAND RDX, RSI # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RSI\n.bb_main.exit:\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> (Note: if you're following along this guide, your detected violation is going to contain a completely different assembly. But don't worry about it, the analysis process is going to be the same.)</p> <p>This is a randomly-generated sequence of assembly instructions, so if we try to find out the source of the unexpected leakage in it, we will have to put a very considerable effort. Fortunately, we don't have to do it, as there are several techniques that can significantly simplify the analysis.</p>"},{"location":"fuzzing-guide/#1-remove-irrelevant-instructions-from-the-program","title":"1. Remove irrelevant instructions from the program","text":"<pre><code>rvzr minimize -s base.json -c config.yaml -i /results/violation&lt;timestamp&gt;.asm -o min.asm -n 100\n</code></pre> <p>It simplifies the program and stores the result into <code>min.asm</code>. The result is:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\n.function_main:\n.bb_main.entry:\n.bb_main.0:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nINC DL\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.bb_main.exit:\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>We can further simplify the test case manually, by removing the unused labels (e.g., <code>bb_main.0</code>). Note that <code>.test_case_enter:</code> and <code>.test_case_exit:</code> have to remain because Revizor's automation scripts use it to define the start and the end of the test case.</p> <p>As a result, we get a minimal version of the program:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB word ptr [R14 + RAX], DX\nINC DL\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>To make sure that we didn't make a mistake while modifying the program, we can verify the result by reproducing the violation:</p> <pre><code>rvzr fuzz -s base.json -c config.yaml -t min.asm -i 100\n</code></pre>"},{"location":"fuzzing-guide/#2-add-speculation-fences-to-narrow-down-the-part-of-the-program-that-causes-leakage","title":"2. Add speculation fences to narrow down the part of the program that causes leakage","text":"<pre><code>rvzr minimize -s base.json -c config.yaml -i min.asm -o min.asm -n 100 --add-fences\n</code></pre> <p>This command iteratively attempts to add an <code>LFENCE</code> before every instruction in the program while checking if the violation persists. The result is:</p> <pre><code>.intel_syntax noprefix\nMFENCE # instrumentation\n.test_case_enter:\nLFENCE\nAND RAX, 0b1111111111111 # instrumentation\nLFENCE\nLOCK SBB word ptr [R14 + RAX], DX\nAND RBX, 0b1111111111111 # instrumentation\nLOCK DEC byte ptr [R14 + RBX]\nAND RBX, 0b1111111111111 # instrumentation\nSBB DL, byte ptr [R14 + RBX]\nOR RBX, 1 # instrumentation\nAND RDX, RBX # instrumentation\nSHR RDX, 1 # instrumentation\nDIV RBX\nAND RDX, 0b1111111111111 # instrumentation\nMUL dword ptr [R14 + RDX]\nAND RAX, 0b1111111111111 # instrumentation\nLOCK SBB byte ptr [R14 + RAX], CL\n.test_case_exit:\nMFENCE # instrumentation\n</code></pre> <p>Only two fences were inserted, after <code>.test_case_enter:</code> and after <code>AND RAX, 0b1111111111111</code>. It means that all the remaining instructions are somehow involved in the speculative leak (although we cannot yet tell how exactly).</p>"},{"location":"fuzzing-guide/#3-use-the-statistics-reported-by-revizor-to-find-the-specific-instruction-that-triggers-speculation","title":"3. Use the statistics reported by Revizor to find the specific instruction that triggers speculation","text":"<p>At this point, we start making manual changes to the program. We go through the program, try removing instructions one at a time, execute the modified program on Revizor, and check the statistic from the speculation filter.</p> <p>For example, let's say we start from the bottom. We first try to remove the last line (<code>LOCK SBB byte ptr [R14 + RAX], CL</code>), and execute the program on Revizor: <pre><code>rvzr fuzz -s base.json -c config.yaml -t min.asm -i 100\n\nINFO: [fuzzer] Starting at 17:16:52\n0     ( 0%)| Stats:\n================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 200.0\nFlaky violations: 0\nRequired priming: 0\nViolations: 0\nEffectiveness:\n  Effectiveness: 1.0\n  Total Cls: 20.0\n  Effective Cls: 20.0\nFilters:\n  Speculation Filter: 1\nObservation Filter: 1\n</code></pre></p> <p>Even though Revizor did not report a violation, the line <code>Speculation Filter: 1</code> tells us that Revizor detected some speculation. Accordingly, we deduce that the instruction we removed (<code>LOCK SBB</code>) is not the source of speculation.</p> <p>We continue the process with one instruction at a time, and we see the same result with the next three instructions (<code>AND</code>, <code>MUL</code>, and <code>AND</code>). However, when we try removing <code>DIV</code> from the program, we Revizor produces the following output:</p> <pre><code>================================ Statistics ===================================\nTest Cases: 1\nInputs per test case: 200.0\nFlaky violations: 0\nRequired priming: 0\nViolations: 0\nEffectiveness:\n  Effectiveness: 0.0\n  Total Cls: 0.0\n  Effective Cls: 0.0\nFilters:\n  Speculation Filter: 0\nObservation Filter: 0\n</code></pre> <p>The line <code>Speculation Filter: 0</code> tells us that Revizor did not detect any speculation while executing the version of the program without <code>DIV</code>. It means that this division was the source of speculative leakage.</p>"},{"location":"fuzzing-guide/#4-to-be-continued","title":"4. TO BE CONTINUED...","text":""},{"location":"how-revizor-works/","title":"How Revizor works","text":""},{"location":"how-revizor-works/#revizor-in-a-nutshell","title":"Revizor in a nutshell","text":"<p>Revizor is a tool for detecting unexpected microarchitectural leakage in CPUs. Microarchitectural leakage means the information that an attacker could learn by launching a microarchitectural side-channel attack (e.g., Spectre or Meltdown). The expected microarchitectural leakage is the leakage that we already know about (i.e., known microarchitectural vulnerabilities). We describe the expected leakage in a form of a Speculation Contract (see below). Accordingly, the unexpected leakage is any leakage not described pby a contract - we call it a contract violation. Revizor's task is to find such violations.</p>"},{"location":"how-revizor-works/#speculation-contracts","title":"Speculation Contracts","text":"<p>Below is a brief intro to Contracts. You can find a more detailed description in the original paper and in the Background section of the Revizor paper.</p>"},{"location":"how-revizor-works/#microarchitectural-leakage-and-hardware-traces","title":"Microarchitectural Leakage and Hardware Traces","text":"<p>Consider two programs, an attacker and a victim. The attacker launches a microarchitectural side-channel attack (e.g., a cache side channel) to spy on the victim and learn some of its data. A hardware trace is a sequence of all the observations made through this side-channel after each instruction during the victim's execution. In other words, hardware trace is the result for a side-channel attack.</p> <p>We abstractly represent the hardware trace as the output of a function</p> <p>\ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>that takes three input parameters: (1) the victim program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54; (2) the input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e processed by the victim\u2019s program (i.e., the architectural state including registers and main memory); (3) the microarchitectural context \ud835\udc36\ud835\udc61\ud835\udc65 in which it executes. The information exposed by a hardware trace depends on the assumed side-channel and threat model.</p> <p>Example: If the threat model includes attacks on a data cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is composed of the cache set indexes used by \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54\u2019s loads and stores. If it includes attacks on an instruction cache, \ud835\udc3b\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the addresses of executed instructions.</p> <p>A program leaks information via side-channels when its hardware traces depend on the inputs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e): We assume the attacker knows \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and can manipulate \ud835\udc36\ud835\udc61\ud835\udc65, hence any difference between the hardware traces implies difference in \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e, which effectively exposes information to the attacker.</p>"},{"location":"how-revizor-works/#whats-a-speculation-contract","title":"What's a Speculation Contract?","text":"<p>A speculation contract specifies the information that can be exposed by a CPU during a program execution under a given threat model. For each instruction in the CPU ISA (or a subset thereof), a contract describes the information exposed by the instruction\u2019s (observation clause) and the externally-observable speculation that the instruction may trigger (execution clause). When a contract covers a subset of ISA, the leakage of unspecified instructions is undefined.</p> <p>Example: consider the contract summarized in the next table:</p> Observation Clause Execution Clause Load Expose Address - Store Expose Address - Cond. Jump - Mispredict Target Other - - <p>We call this contract MEM-COND. Through the observation clauses of loads and stores, the contract prescribes that addresses of all memory access may be exposed (hence MEM). The execution clause of conditional branches describes their misprediction, thus the contract prescribes that branch targets may be mispredicted (hence COND). This way, the contract models a data cache side channel on a CPU with branch prediction.</p> <p>A contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 contains the sequence of all the observations the contract allows to be exposed after each instruction during a program execution, including the instructions executed speculatively. Conversely, the information that is not exposed via \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 is supposed to be kept secret.</p> <p>We abstractly represent a contract as a function \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 that maps the program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54 and its input \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e to a contract trace \ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52:</p> <p>\ud835\udc36\ud835\udc47\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc52 = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e)</p> <p>Example: Consider the following program:</p> <p><pre><code>z = array1[x] # base of array1 is 0x100\nif y &lt; 10:\n    z = array2[y] # base of array2 is 0x200\n</code></pre> It is executed with an input <code>data={x=10,y=20}</code>. The MEM-COND contract trace is <code>ctrace=[0x110,0x220]</code>, representing that the load at line 1 exposes the accessed address during normal execution, and the load at line 3 exposes its address during speculative execution triggered by the branch at line 2.</p> <p>A CPU complies with a contract when its hardware traces (collected on the actual CPU) leak at most as much information as the contract traces. Formally, we require that whenever any two executions of any program have the same contract trace (implying the difference between inputs is not exposed), the respective hardware traces should also match.</p> <p>A CPU complies with a \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61 if, for all programs \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, all input pairs (\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032), and all initial microarchitectural states \ud835\udc36\ud835\udc61\ud835\udc65:</p> <p>\ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e) = \ud835\udc36\ud835\udc5c\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) -&gt; \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc36\ud835\udc61\ud835\udc65) = \ud835\udc34\ud835\udc61\ud835\udc61\ud835\udc4e\ud835\udc50\ud835\udc58(\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032,\ud835\udc36\ud835\udc61\ud835\udc65)</p> <p>Conversely, a CPU violates a contract if there exists a program \ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54, a microarchitectural state Ctx, and two inputs \ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032 that agree on their contract traces but disagree on the hardware traces. We call the tuple (\ud835\udc43\ud835\udc5f\ud835\udc5c\ud835\udc54,\ud835\udc36\ud835\udc61\ud835\udc65,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e,\ud835\udc37\ud835\udc4e\ud835\udc61\ud835\udc4e\u2032) a contract counterexample. The counterexample witnesses that an adversary can learn more information from hardware traces than what the contract specifies. A counterexample indicates a potential microarchitectural vulnerability that was not accounted for by the contract.</p>"},{"location":"how-revizor-works/#model-based-relational-testing","title":"Model-based Relational Testing","text":"<p>To find contract violations, we use the following approach, which we call Model-based Relational Testing (MRT).</p> <p>The next figure show the main components of MRT:</p> <p></p> <p>Test case and input generation. We sample the search space of programs, inputs and microarchitectural states to find counterexamples. The generated instruction sequences (test cases) are comprised of the ISA subset described by the contract. The test cases and respective inputs to them are generated to achieve high diversity and to increase speculation or leakage potential.</p> <p>Collecting contract traces. We implement an executable Model of the contract to allow automatic collection of contract traces for standard binaries. For this, we modify a functional CPU emulator to implement speculative control flow based on a contract\u2019s execution clause, and to record traces based on its observation clause.</p> <p>Collecting hardware traces. We collect hardware traces by executing the test case on the CPU under test and measuring the observable microarchitectural state changes during the execution according to the threat model. The executor employs several methods to achieve consistent and repeatable measurements.</p> <p>Relational Analysis. Based on the collected contract and hardware traces, we identify contract violations. Namely, we search for pairs of inputs that match the following:</p> <pre><code>ContractTrace1 == ContractTrace2\n               and\nHardwareTrace1 != HardwareTrace2\n</code></pre> <p>This requires relational reasoning: * We partition inputs into groups, which we call input classes. All inputs within a class have the same contract trace. Thus, input classes correspond to the equivalence classes of equality on contract traces. Classes with a single (ineffective) input are discarded. * For each class, we check if all inputs within a class have the same hardware trace.</p> <p>If the check fails on any of the classes, we found a counterexample that witnesses contract violation.</p>"},{"location":"how-revizor-works/#revizor","title":"Revizor","text":"<p>Revizor implements the MRT approach for black-box CPUs. The implementation details are described in Revizor Architecture.</p>"},{"location":"install/","title":"Installation","text":"<p>Warning: Keep in mind that the Revizor runs randomly-generated code in kernel space. As you can imagine, things could go wrong. Make sure you're not running Revizor on an important machine.</p>"},{"location":"install/#1-check-requirements","title":"1. Check Requirements","text":"<ul> <li> <p>Architecture: Revizor supports Intel and AMD x86-64 CPUs. We also have experimental support for ARM CPUs (see <code>arm-port</code> branch) but it is at very early stages, use it on your own peril.</p> </li> <li> <p>No virtualization: You will need a bare-metal OS installation. Testing from inside a VM is not (yet) supported.</p> </li> <li> <p>OS: The target machine has to be running Linux v4.15 or later.</p> </li> </ul>"},{"location":"install/#2-install-revizor-python-package","title":"2. Install Revizor Python Package","text":"<p>If you use <code>pip</code>, you can install Revizor with:</p> <pre><code>pip install revizor-fuzzer\n</code></pre> <p>Alternatively, install Revizor from sources: <pre><code># run from the project root directory\nmake install\n</code></pre></p>"},{"location":"install/#3-install-revizor-executor-kernel-module","title":"3. Install Revizor Executor (kernel module)","text":"<p>Then build and install the kernel module:</p> <pre><code># building a kernel module require kernel headers\nsudo apt-get install linux-headers-$(uname -r)\n\n# get the source code\ngit clone https://github.com/microsoft/sca-fuzzer.git\n\n# build the executor\ncd sca-fuzzer/src/x86/executor\nmake uninstall  # the command will give an error message, but it's ok!\nmake clean\nmake\nmake install\n</code></pre>"},{"location":"install/#4-download-isa-spec","title":"4. Download ISA spec","text":"<pre><code>rvzr download_spec -a x86-64 --extensions BASE SSE SSE2 CLFLUSHOPT CLFSH --outfile base.json\n</code></pre>"},{"location":"install/#5-optional-system-configuration","title":"5. (Optional) System Configuration","text":"<p>For more stable results, disable hyperthreading (there's usually a BIOS option for it). If you do not disable hyperthreading, you will see a warning every time you invoke Revizor; you can ignore it.</p> <p>Optionally (and it really is optional), you can boot the kernel on a single core by adding <code>-maxcpus=1</code> to the boot parameters (how to add a boot parameter).</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":""},{"location":"quick-start/#testbed","title":"Testbed","text":"<p>Get yourself a machine for testing: Revizor can test x86-64 CPUs, Intel or AMD. You will need a Linux installation running directly on the hardware (testing from within a VM is not supported).</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>Follow the installation instructions on this page.</p>"},{"location":"quick-start/#config-file","title":"Config File","text":"<p>The fuzzing process is controlled by a configuration file in the YAML format, passed via <code>--config</code> option. At the very minimum, this file should contain the following fields: * <code>contract_observation_clause</code> and <code>contract_execution_clause</code> describe the contract that the CPU-under-test is tested against. See this page for a list of available contracts. If you don't know what a contract is, Sec. 3 of this paper will give you a high-level introduction to contracts, and this paper will provide a deep dive into contracts. * <code>instruction_categories</code> is a list of instruction types that will be tested. Effectively, Revizor uses this list to filter out instructions from <code>base.json</code> (the file you downloaded via <code>rvzr download_spec</code>).</p> <p>For a full list of configuration options, see docs.</p>"},{"location":"quick-start/#baseline-experiment","title":"Baseline Experiment","text":"<p>After a fresh installation, it is normally a good idea to do a quick test run to check that everything works ok.</p> <p>For example, we can create a configuration file <code>config.yaml</code> with only simple arithmetic instructions. As this instruction set does not include any instructions that would trigger speculation on Intel or AMD CPUs (at least that we know of), the expected contract would be <code>CT-SEQ</code>:</p> <pre><code># config.yaml\ninstruction_categories:\n- BASE-BINARY  # arithmetic instructions\nmax_bb_per_function: 1  # no branches!\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n- no_speculation  # aka SEQ\n</code></pre> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 100 -c config.yaml  -w .\n</code></pre></p> <p>This command should terminate with no violations.</p>"},{"location":"quick-start/#detection-of-a-simple-contract-violation","title":"Detection of a Simple Contract Violation","text":"<p>Next, we could intentionally make a mistake in a contract to check that Revizor can detect it. To this end, we can modify the config file from the previous example to include instructions that trigger speculation (e.g., conditional branches) but keep the contract the same: <pre><code># config.yaml\ninstruction_categories:\n- BASE-BINARY  # arithmetic instructions\n- BASE-COND_BR\nmax_bb_per_function: 5  # up to 5 branches per test case\nmin_bb_per_function: 1\n\ncontract_observation_clause: loads+stores+pc  # aka CT\ncontract_execution_clause:\n- no_speculation  # aka SEQ\n</code></pre></p> <p>Start the fuzzer: <pre><code>rvzr fuzz -s base.json -i 50 -n 1000 -c config.yaml -w .\n</code></pre></p> <p>As your CPU-under-test almost definitely implements branch prediction, Revizor should detect a violation within a few minutes, with a message similar to this:</p> <pre><code>================================ Violations detected ==========================\n  Contract trace (hash):\n\n    0111010000011100111000001010010011110101110011110100000111010110\n  Hardware traces:\n   Inputs [907599882]:\n    .....^......^......^...........................................^\n   Inputs [2282448906]:\n    ...................^.....^...................................^.^\n</code></pre> <p>You can find the violating test case as well as the violation report in the directory named <code>./violation-*/</code>. It will contain an assembly file <code>program.asm</code> that surfaced a violation, a sequence of inputs <code>input-*.bin</code> to this program, and some details about the violation in <code>report.txt</code>.</p>"},{"location":"quick-start/#full-scale-fuzzing-campaign","title":"Full-Scale Fuzzing Campaign","text":"<p>To start a full-scale test, write your own configuration file (see description here and an example config here), and launch the fuzzer.</p> <p>Below is a example launch command, which will start a 24-hour fuzzing session, with 100 input classes per test case, and which uses big-fuzz.yaml configuration: <pre><code>rvzr fuzz -s base.json -c src/tests/big-fuzz.yaml -i 100 -n 100000000 --timeout 86400 -w `pwd` --nonstop\n</code></pre></p> <p>When you find a violation, you will have to do some manual investigation to understand the source of it; this guide is an example of how to do such an investigation.</p>"},{"location":"trophies/","title":"Trophies","text":""},{"location":"trophies/#newly-discovered-vulnerabilities","title":"Newly discovered vulnerabilities","text":""},{"location":"trophies/#string-comparison-overrun-sco","title":"String Comparison Overrun (SCO)","text":"<p>The page is under construction</p>"},{"location":"trophies/#zero-dividend-injection-zdi","title":"Zero Dividend Injection (ZDI)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v1-var-and-v4-var","title":"Spectre V1-Var and V4-Var","text":"<p>The page is under construction</p>"},{"location":"trophies/#store-based-spectre-v1","title":"Store-based Spectre V1","text":"<p>The page is under construction</p>"},{"location":"trophies/#speculative-store-with-forwarding","title":"Speculative Store with Forwarding","text":"<p>The page is under construction</p>"},{"location":"trophies/#known-vulnerabilities-automatically-reproduced-by-revizor","title":"Known vulnerabilities automatically reproduced by Revizor","text":""},{"location":"trophies/#spectre-v1-bounds-check-bypass-bcb","title":"Spectre V1 (Bounds Check Bypass, BCB)","text":"<p>The page is under construction</p>"},{"location":"trophies/#spectre-v4-speculative-store-bypass-ssbp","title":"Spectre V4 (Speculative Store Bypass, SSBP)","text":"<p>The page is under construction</p>"},{"location":"trophies/#meltdown-smap-variant","title":"Meltdown (SMAP variant)","text":"<p>The page is under construction</p>"},{"location":"trophies/#foreshadow-l1tf","title":"Foreshadow (L1TF)","text":"<p>The page is under construction</p>"},{"location":"trophies/#microarchitectural-data-sampling-mds","title":"Microarchitectural Data Sampling (MDS)","text":"<p>The page is under construction</p>"},{"location":"trophies/#load-value-injection-lvi-including-lvi-null","title":"Load Value Injection (LVI), including LVI-Null","text":"<p>The page is under construction</p>"}]}